
## ‚öôÔ∏è SPI Peripheral

### Overview
SPI Module Implementation

The SPI module supports master and slave modes with configurable clock polarity/phase, data size, and prescaler. It uses a FSM for transaction control and double buffering for reliable data handling.

### üîπ Key Features
- Master/slave operation
- Data sizes: 8, 16, 32 bits
- All 4 SPI modes (CPOL/CPHA)
- Programmable prescaler (3 bits)
- Interrupt on transfer complete
- Double buffering to prevent data loss
- Overflow flag for unserviced data

### Internal Architecture
| Block | Description |
|:------|:-------------|
| **FSM** | 4-states: IDLE, ASSIGN_CS, TRANSMISSION, END for transaction control. |
| **Prescaler** | Divides clk based on control_reg[4:2] to generate prescale_clk. |
| **SCLK Controller** | Generates sclk based on CPOL/CPHA in master mode. |
| **CS Controller** | Manages chip select and start delays. |
| **Shift Register** | Handles serial shift in/out for data transfer. |
| **Buffers** | Double buffers (buffer1, buffer2) for read data pipeline. |

Inputs (All are wires by default):
- clk (1 bit, wire): System clock.
- rst (1 bit, wire): Asynchronous reset.
- PWDATA (32 bits, wire): Data from APB write channel.
- PWRITE (1 bit, wire): APB write control signal.
- PENABLE (1 bit, wire): APB enable signal.
- PSEL (1 bit, wire): APB peripheral select.
- miso (1 bit, wire): Master-In Slave-Out data line (input from slave).
- control_reg (11 bits, wire): Control and configuration register.

Outputs:
- mosi (1 bit, reg): Master-Out Slave-In data line (output to slave).
- interrupt_spi (1 bit, reg): Interrupt signal set after successful transmission.
- control_reg_out_bo (3 bits, reg): Status flags output (overflow and buffer full flags).
- PREADY (1 bit, reg): Indicates SPI is ready for the next APB transaction.
- PRDATA (32 bits, wire): Read data sent to APB from the SPI buffer.

Inouts (All are wires by default):
- cs (1 bit, wire): Chip Select line (driven in master mode, input in slave mode).
- sclk (1 bit, wire): Serial Clock line (driven in master mode, input in slave mode).

### FSM and Module Coordination in SPI
All the state changes are synchronized with the positive edge of prescaled_clk

The SPI module operates using a 4-state finite state machine (FSM): IDLE, ASSIGN CS, TRANSMISSION, and END. This FSM governs the entire data flow ‚Äî from command initiation to SPI transfer and interrupt generation.

State transitions and data operations are performed on the prescaled clock, which is generated by the prescaler module based on control bits. The prescaler reduces the system clock frequency to match SPI timing requirements.

The phase signal toggles with each prescale clk edge and is used to distinguish between actions performed at the positive edge (e.g., shift in MISO, FSM transition) and the negative edge (e.g., driving MOSI) ‚Äî enabling CPHA-style behavior.

Some control logic, like APB interface handling, buffer management, and interrupt generation, runs on the system clock (clk), allowing synchronization with the host system.

Three submodules are instantiated to offload specialized tasks:
- prescaler: Divides the system clock as per control reg[4:2], generating prescale clk.
- sclk controller: Generates the SPI serial clock (sclk) based on CPOL/CPHA and master/slave mode.
- cs controller: Manages chip select (cs), detects start conditions, and coordinates slave enablement.

This modular approach keeps the design scalable, timing accurate, and protocol-compliant.

### Data Buffering System in SPI Module
The SPI module uses a structured 3-stage data buffering system to separate write and read operations and ensure smooth data transfer:

1. Write Data Flow (APB to SPI)  
When the APB issues a write command (PWRITE = 1, PSEL = 1, PENABLE = 1), the 32-bit data from PWDATA is latched into the internal write buffer named buffer.  
The signal start command is set, initiating the SPI FSM.  
In the IDLE ‚ÜíASSIGN CS transition (posedge prescale clk), the buffer value is loaded into shift reg for transmission to the SPI slave.

2. SPI Transmission (Shift Register Behavior)  
In the TRANSMISSION state, shift reg operates as a shift register:  
On posedge of prescale clk and when phase = 1, the MISO bit is shifted in:  
shift_reg <= {shift_reg[30:0], miso};  

On negedge of prescale clk (phase = 0), the MSB of shift reg is driven out to MOSI:  
mosi <= shift_reg[31];  

The number of bits shifted (8, 16, or 32) is determined by control reg[6:5].

3. Post-Transmission Data Storage  
When all bits are transmitted (bit cnt reaches 7, 15, or 31), the FSM moves to the END state.  
At this point:  
- The final contents of shift reg (which now holds received MISO bits) are moved to buffer 1.  
- The existing buffer 1 value is moved to buffer 2, implementing a read data pipeline.

### Control Register Output Status Bits
The module provides status feedback via control reg out bo[10:8]:

- control reg out bo[8] (Overflow Flag): Set if a third read occurs before the previous buffers are emptied.
- control reg out bo[9] (Buffer Full 1): Set when buffer 1 holds unread data.
- control reg out bo[10] (Buffer Full 2): Set when both buffer 1 and buffer 2 are filled, i.e., no read occurred since last two transmissions.

These flags are cleared during an APB read operation (PWRITE = 0) depending on which buffer is read. The logic in the always @(posedge clk) block updates the status bits based on this.

### Interrupt Generation
The output interrupt spi is asserted in the END state, indicating that a new word has been received and the buffer(s) have been updated.  
This allows the host to respond asynchronously (e.g., via an interrupt service routine) and read the updated data.

### Read Data Flow (SPI to APB)
The host reads received data through the PRDATA output.  
If a read occurs (PWRITE = 0) while PREADY = 1:  
- If only buffer 1 is filled (control reg[9] = 1 and control reg[10] = 0), it outputs buffer 1.  
- If both buffers are full, it outputs buffer 2.  

The assign statement controlling PRDATA ensures that only valid data is placed on the APB read bus.

### APB Protocol and PREADY Signal
In the APB protocol:  
- PREADY = 1 indicates the slave is ready to accept a write or return a read.  
- PREADY = 0 tells the bus master (e.g., processor) to wait and retry the transaction later.  

Thus, PREADY acts as a handshake acknowledgment from the SPI module to the bus interface.

### When is PREADY Set and Cleared?
PREADY is controlled in the always @(posedge clk) block based on the FSM state and the start command signal:  

1. In the IDLE state:  
If no transfer is ongoing (start command == 0), PREADY is set to 1.  
This tells the APB master that the SPI is ready to accept a new write (PWDATA) or return read data (PRDATA).  
This is also when read requests are served via the PRDATA output, and buffer/status bits may get cleared.

2. When a transfer is about to begin (start command == 1):  
PREADY is immediately set to 0, indicating that the module is busy handling the SPI transfer and cannot respond to new APB requests.

3. In all other FSM states (ASSIGN CS, TRANSMISSION, END):  
PREADY remains low (0), maintaining bus synchronization.

4. At the end of a transmission (END state):  
Once the FSM returns to IDLE, PREADY is reasserted (set to 1), signaling readiness for the next APB transaction.

### Importance of Proper PREADY Control
Proper control of PREADY ensures:  
- No write happens while SPI is still busy shifting out previous data.  
- No read occurs before fresh data is valid.  
- Synchronization between asynchronous APB transactions and sequential SPI protocol timing.  
- Prevents data corruption and maintains protocol compliance.  

In a real-world SPI implementation, using both the posedge and negedge of SCLK to drive logic‚Äîsuch as sampling and shifting the same shift register‚Äîcan lead to conflicting behavior. If both edges control the shift register simultaneously, there‚Äôs a risk of data corruption or race conditions, especially if the same register is written from two different clock edges. Moreover, such dual-edge-triggered logic is generally not synthesizable in most FPGA or ASIC tools, as it creates ambiguity in timing and resource allocation.  
To avoid this, the current design uses a single-edge-controlled clock (prescale clk) that is internally faster than SCLK and toggles a phase signal. This phase controls whether the current half-cycle performs input sampling or output shifting, achieving safe, deterministic behavior without relying on both edges of SCLK.

### Need for prescale clk When SCLK Exists
To manage precise timing for data transmission and reception, the SPI module uses a signal named phase, which toggles on every positive edge of the prescale clk. This prescale clk is a divided-down version of the system clock and operates at twice the frequency of the generated SCLK signal.  
The phase signal effectively creates two internal sub-cycles per SCLK cycle:  
- When phase is high, the module handles tasks such as state transitions and sampling incoming data (MISO) into the shift register.  
- When phase is low, it drives the next data bit onto the MOSI line.  

This clean separation ensures that data is always driven and sampled in different half-cycles, avoiding race conditions. If only SCLK had been used with both its posedge and negedge for triggering logic (e.g., sampling and shifting), it would introduce timing conflicts‚Äîsince the same clock edge might be used simultaneously by both the master and slave for different operations.  
The use of a faster internal clock (prescale clk) along with phase provides finer control, prevents such conflicts, and ensures reliable communication across all SPI modes defined by CPOL and CPHA.

### Explanation of control reg Bits (11 bits total)
Bit-level description:

| 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
|----|---| - | - | - | - | - | - | - | - | - |
| Buf2 | Buf1 | OVR | MST | SIZE | | PRESC | | | CPHA | CPOL |

- control reg[0]: CPOL
- control reg[1]: CPHA
- control reg[4:2]: Prescaler value (for SCLK division)
- control reg[6:5]: Transfer size ‚Äî 8, 16, or 32 bits
- control reg[7]: Master (1) or Slave (0)
- control reg[8]: Overflow flag (writable/clearable?)
- control reg[9]: Buffer 1 full flag
- control reg[10]: Buffer 2 full flag

Out of all these, only control reg[10:8] are set by the SPI module. All other bits come from the processor.  
Note: This overflow bit, when high, does not stop further data transfer ‚Äî it is actually an indication to the programmer that some data is lost as the interrupt was not serviced properly.

### Master and Slave Mode
In master mode (control reg[7] = 1), the SPI module generates the SCLK and controls the CS (chip select) line. It initiates communication by actively driving these signals and managing the transmission process. In contrast, in slave mode (control reg[7] = 0), the module does not drive SCLK or CS; instead, it waits for an external master to assert CS and provide the clock signal.  
To support both roles, the sclk and cs lines are declared as inout and are only driven when the module is in master mode. In slave mode, these signals are placed in a high-impedance (tristate) state, allowing an external master to control them without contention. This tristate behavior is essential for ensuring safe and conflict-free operation when multiple devices share the SPI bus.  
It also needs to be noted that in our implementation the master can work on all the four clock modes but the slave can only work in mode cpol = 0 & cpha = 0.

### Why Two Buffers Are Used for Reading Data
The SPI module includes two buffers during read operations to prevent data loss in full-duplex communication. When a transfer completes, the received data is stored in buffer 1, and an interrupt is triggered to notify the APB side.  
However, if a second SPI transfer occurs before the APB master services the first interrupt and reads the data, and since PREADY is low during this time (indicating the interface is not yet ready), the newly received data cannot overwrite buffer 1 without risking loss. To handle this, the second received data is stored in buffer 2. This ensures both data words are preserved even if the APB interface hasn‚Äôt completed the previous read transaction, maintaining reliable data integrity across consecutive SPI transfers.

### Default Reset Behavior
Clarify what happens at rst = 1:  
- FSM goes to IDLE  
- Buffers and control bits cleared  
- PREADY = 1  

### Implementation of SCLK
The SPI hardware is structured in such a way that, for SPI Mode 0 (CPOL = 0, CPHA = 0), it appears to the slave that data toggling happens on the falling edge of SCLK and sampling occurs on the rising edge ‚Äî as expected for that mode. However, for other SPI modes like Mode 3 (CPOL = 1, CPHA = 1), this behavior must be reversed: toggling should occur on the rising edge, and sampling on the falling edge.  
Since our design does not internally use the edges of SCLK for logic control, it instead generates the SCLK output purely for the slave‚Äôs reference, while internally relying on a faster prescale clk and adjusted control logic. This allows the SPI slave to perceive correct edge behavior according to the selected mode, even though the hardware itself is not synchronized directly to the actual rising or falling edge of SCLK. This abstraction ensures SPI compliance while keeping the internal circuit clean, synthesizable, and free of clock edge conflicts.

The sclk controller is responsible for generating the serial clock (SCLK) in master mode while ensuring compatibility with external clocking in slave mode. It takes several control inputs: cpol (clock polarity), cpha (clock phase), master slave (mode select), rst, and the internal prescale clk. The output sclk is declared as inout because its behavior changes depending on the mode of operation.  
Inside the module, a clock signal is toggled on every positive edge of prescale clk, producing a square wave at half the frequency ‚Äî which forms the base for SCLK. The signal edge selector is computed as cpol ^ cpha to align with the SPI mode and determine whether the clock should be phase-shifted or not.  
The sclk line is assigned using a conditional drive:  
assign sclk = (master_slave) ? (clock ^ edge_selector) : 1‚Äôbz;  

This ensures that in master mode (master slave = 1), the module actively drives the sclk line with the appropriate waveform and phase shift, depending on the selected SPI mode. In slave mode (master slave = 0), sclk is placed in a high-impedance (1‚Äôbz) state, allowing an external SPI master to drive the line without contention.

### cs controller Module Implementation
Port List  
Inputs: rst, prescale clk, PWRITE, phase, state[1:0], master slave, cpha, cpol  
Outputs: slave enable, start transfer  
Inouts: cs  

Master Mode (master slave = 1)  
- Drives the cs line using an internal cs out signal.  
- cs out is set to 0 during ASSIGN CS or TRANSMISSION states, and 1 during IDLE or END.  
- Uses internal cnt clk to delay start transfer depending on the SPI mode (CPOL/CPHA).  
- SPI Mode-specific start delays:  
  - Mode 0 / Mode 2 (CPHA = 0): Transfer starts after 1 cycle.  
  - Mode 1 (CPHA = 1, CPOL = 0): Transfer starts after 1 cycle.  
  - Mode 3 (CPHA = 1, CPOL = 1): Transfer starts after 3 cycles.  

Slave Mode (master slave = 0)  
- cs is tristated (1‚Äôbz) and monitored externally.  
- If cs == 0 and the FSM is in IDLE, slave enable is set.  
- If cs == 1, slave enable is cleared.  
- start transfer is not driven; the slave reacts to external CS and clock.  

Importance of cnt clk  
- cnt clk introduces a delay in asserting start transfer to match correct SPI edge timing.  
- Ensures data sampling aligns with SPI clock edges according to the selected CPOL/CPHA mode.  
- Enables compatibility with all 4 SPI modes using a unified FSM design.

### How to Use SPI
The SPI peripheral is located at 0x00010004. To operate in master mode:  
- Use set spi to configure mode (CPOL/CPHA), data size, and master/slave.  
- Compute the SPI address.  
- Write the transmit data.  

Example:  
```
SPI : ; SPI address is 0x00010004
org 0x00000000:
set spi 7,6,5
; Master mode, 32-bit, SPI Mode 0 (CPHA=0, CPOL=0)
movu r1,0x0001
addh r1,r1,0x0004
; SPI address = 0x00010004
mov r2,0xF0F0
; Data to transmit
st r2,0[r1]
; Start SPI transfer
```

| Problem | Cause | Solution |
|:---------|:------|:----------|
| Data corruption | Clock edge conflict | Use phase for separation |
| Overflow | Unserviced interrupt | Monitor overflow flag |

---